# 前端导航优化实施指南

## 快速开始

本指南提供具体的代码示例和实施步骤，帮助开发团队快速执行导航优化计划。

## 第一阶段实施指南

### 1. 动态权限系统

#### Step 1: 创建权限相关的类型定义

```typescript
// shared/types/auth.ts
export interface UserRole {
  id: string;
  name: string;
  permissions: string[];
}

export interface UserWithRoles extends User {
  roles: string[];
  permissions?: string[];
}

export type RoutePermission = {
  path: string;
  roles?: string[];
  permissions?: string[];
};
```

#### Step 2: 创建权限检查Hook

```typescript
// client/src/hooks/use-permissions.ts
import { useAuth } from './use-auth';

export function usePermissions() {
  const { user } = useAuth();
  
  const hasRole = (role: string): boolean => {
    return user?.roles?.includes(role) || false;
  };
  
  const hasAnyRole = (roles: string[]): boolean => {
    return roles.some(role => hasRole(role));
  };
  
  const hasAllRoles = (roles: string[]): boolean => {
    return roles.every(role => hasRole(role));
  };
  
  const hasPermission = (permission: string): boolean => {
    return user?.permissions?.includes(permission) || false;
  };
  
  return {
    hasRole,
    hasAnyRole,
    hasAllRoles,
    hasPermission,
    isAdmin: hasRole('admin'),
    isSuperAdmin: hasRole('superadmin'),
  };
}
```

#### Step 3: 创建RoleRoute组件

```typescript
// client/src/components/auth/RoleRoute.tsx
import React from 'react';
import { Redirect } from 'wouter';
import { usePermissions } from '@/hooks/use-permissions';
import { LoadingSpinner } from '@/components/ui/loading-spinner';

interface RoleRouteProps {
  path: string;
  component: React.ComponentType<any>;
  roles?: string[];
  permissions?: string[];
  fallback?: string;
  requireAll?: boolean;
}

export function RoleRoute({ 
  component: Component, 
  roles = [], 
  permissions = [], 
  fallback = '/platform/403',
  requireAll = false,
  ...rest 
}: RoleRouteProps) {
  const { hasAnyRole, hasAllRoles, hasPermission } = usePermissions();
  const { user, isLoading } = useAuth();
  
  if (isLoading) {
    return <LoadingSpinner />;
  }
  
  if (!user) {
    sessionStorage.setItem('redirect_after_login', rest.path);
    return <Redirect to="/platform/auth" />;
  }
  
  // 检查角色
  if (roles.length > 0) {
    const hasRequiredRoles = requireAll ? hasAllRoles(roles) : hasAnyRole(roles);
    if (!hasRequiredRoles) {
      return <Redirect to={fallback} />;
    }
  }
  
  // 检查权限
  if (permissions.length > 0) {
    const hasRequiredPermissions = requireAll 
      ? permissions.every(p => hasPermission(p))
      : permissions.some(p => hasPermission(p));
      
    if (!hasRequiredPermissions) {
      return <Redirect to={fallback} />;
    }
  }
  
  return <Component {...rest} />;
}
```

#### Step 4: 创建403错误页面

```typescript
// client/src/pages/forbidden-page.tsx
import { Link } from 'wouter';
import { Button } from '@/components/ui/button';
import { ShieldX } from 'lucide-react';

export default function ForbiddenPage() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <div className="max-w-md w-full text-center">
        <ShieldX className="mx-auto h-16 w-16 text-red-500 mb-4" />
        <h1 className="text-4xl font-bold text-gray-900 mb-2">
          403 - 访问受限
        </h1>
        <p className="text-lg text-gray-600 mb-8">
          抱歉，您没有访问此页面的权限。如需访问，请联系管理员。
        </p>
        <div className="space-y-4">
          <Link href="/platform">
            <Button className="w-full">返回主页</Button>
          </Link>
          <Link href="/platform/profile">
            <Button variant="outline" className="w-full">
              查看我的权限
            </Button>
          </Link>
        </div>
      </div>
    </div>
  );
}
```

#### Step 5: 更新App.tsx使用新的权限路由

```typescript
// client/src/App.tsx
import { RoleRoute } from '@/components/auth/RoleRoute';
import ForbiddenPage from '@/pages/forbidden-page';

function Router() {
  return (
    <Switch>
      {/* 公开路由 */}
      <Route path="/" component={LandingRedirect} />
      <Route path="/platform" component={HomePage} />
      <Route path="/platform/auth" component={AuthPage} />
      <Route path="/platform/403" component={ForbiddenPage} />
      
      {/* 需要登录的路由 */}
      <ProtectedRoute path="/platform/events" component={EventsPage} />
      
      {/* 需要特定角色的路由 */}
      <RoleRoute 
        path="/platform/admin" 
        component={AdvancedAdminPage}
        roles={['admin', 'superadmin']}
      />
      
      <RoleRoute 
        path="/platform/admin/interviews" 
        component={InterviewEvaluationPage}
        roles={['admin', 'superadmin']}
        permissions={['manage_interviews']}
      />
      
      {/* 投资人专属路由 */}
      <RoleRoute 
        path="/platform/startups" 
        component={StartupsPage}
        roles={['investor', 'admin']}
      />
      
      {/* 404处理 */}
      <Route component={NotFound} />
    </Switch>
  );
}
```

### 2. 路由预加载实现

#### Step 1: 创建路由配置文件

```typescript
// client/src/config/routes.ts
import { lazy } from 'react';

export const routeComponents = {
  // 懒加载组件映射
  '/platform/ai-matching': lazy(() => import('@/pages/ai-matching-page')),
  '/platform/workspace': lazy(() => import('@/pages/collaboration-workspace-page')),
  '/platform/analytics': lazy(() => import('@/pages/matching-analytics-page')),
  '/platform/marketplace': lazy(() => import('@/pages/ai-marketplace-page')),
  '/platform/reputation': lazy(() => import('@/pages/reputation-dashboard-page')),
  '/platform/discovery': lazy(() => import('@/pages/content-discovery-page')),
  '/platform/messages': lazy(() => import('@/pages/messages-page')),
};

// 预加载优先级配置
export const preloadPriority = {
  high: [
    '/platform/ai-matching',
    '/platform/events',
    '/platform/matching'
  ],
  medium: [
    '/platform/workspace',
    '/platform/community',
    '/platform/marketplace'
  ],
  low: [
    '/platform/analytics',
    '/platform/reputation',
    '/platform/discovery'
  ]
};
```

#### Step 2: 创建预加载管理器

```typescript
// client/src/lib/preload-manager.ts
import { routeComponents } from '@/config/routes';

class PreloadManager {
  private preloadedRoutes = new Set<string>();
  private preloadQueue: string[] = [];
  private isPreloading = false;
  
  // 预加载单个路由
  async preloadRoute(path: string): Promise<void> {
    if (this.preloadedRoutes.has(path)) {
      return;
    }
    
    const component = routeComponents[path];
    if (!component) {
      return;
    }
    
    try {
      await component.preload?.();
      this.preloadedRoutes.add(path);
      console.log(`Preloaded route: ${path}`);
    } catch (error) {
      console.error(`Failed to preload route ${path}:`, error);
    }
  }
  
  // 批量预加载
  async preloadRoutes(paths: string[]): Promise<void> {
    const unloadedPaths = paths.filter(path => !this.preloadedRoutes.has(path));
    
    if (unloadedPaths.length === 0) {
      return;
    }
    
    // 使用 Promise.allSettled 避免单个失败影响其他
    const results = await Promise.allSettled(
      unloadedPaths.map(path => this.preloadRoute(path))
    );
    
    const failed = results.filter(r => r.status === 'rejected').length;
    if (failed > 0) {
      console.warn(`${failed} routes failed to preload`);
    }
  }
  
  // 空闲时预加载
  preloadOnIdle(paths: string[]): void {
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() => {
        this.preloadRoutes(paths);
      }, { timeout: 3000 });
    } else {
      // 降级方案
      setTimeout(() => {
        this.preloadRoutes(paths);
      }, 2000);
    }
  }
  
  // 鼠标悬停预加载
  preloadOnHover(path: string): void {
    // 防抖处理，避免频繁触发
    if (this.preloadedRoutes.has(path)) {
      return;
    }
    
    this.preloadQueue.push(path);
    
    if (!this.isPreloading) {
      this.isPreloading = true;
      setTimeout(() => {
        const uniquePaths = [...new Set(this.preloadQueue)];
        this.preloadQueue = [];
        this.isPreloading = false;
        this.preloadRoutes(uniquePaths);
      }, 100);
    }
  }
  
  // 获取预加载状态
  getStatus(): { total: number; loaded: number; percentage: number } {
    const total = Object.keys(routeComponents).length;
    const loaded = this.preloadedRoutes.size;
    const percentage = Math.round((loaded / total) * 100);
    
    return { total, loaded, percentage };
  }
}

export const preloadManager = new PreloadManager();
```

#### Step 3: 创建预加载Hook

```typescript
// client/src/hooks/use-route-preload.ts
import { useEffect } from 'react';
import { preloadManager } from '@/lib/preload-manager';
import { preloadPriority } from '@/config/routes';

export function useRoutePreload() {
  useEffect(() => {
    // 页面加载后预加载高优先级路由
    preloadManager.preloadOnIdle(preloadPriority.high);
    
    // 5秒后预加载中优先级路由
    const mediumTimer = setTimeout(() => {
      preloadManager.preloadOnIdle(preloadPriority.medium);
    }, 5000);
    
    // 10秒后预加载低优先级路由
    const lowTimer = setTimeout(() => {
      preloadManager.preloadOnIdle(preloadPriority.low);
    }, 10000);
    
    return () => {
      clearTimeout(mediumTimer);
      clearTimeout(lowTimer);
    };
  }, []);
  
  return {
    preloadRoute: preloadManager.preloadRoute.bind(preloadManager),
    preloadOnHover: preloadManager.preloadOnHover.bind(preloadManager),
    getStatus: preloadManager.getStatus.bind(preloadManager),
  };
}
```

#### Step 4: 增强导航组件支持预加载

```typescript
// client/src/components/navbar.tsx
import { useRoutePreload } from '@/hooks/use-route-preload';

export default function Navbar() {
  const { preloadOnHover } = useRoutePreload();
  
  return (
    <nav className="bg-white shadow-md">
      <div className="flex items-center space-x-8">
        {navLinks.map((link) => (
          <Link
            key={link.href}
            href={link.href}
            onMouseEnter={() => preloadOnHover(link.href)}
            className={cn(
              "px-3 py-2 text-sm font-medium transition-colors",
              "hover:text-primary",
              isActive(link.href) && "text-primary border-b-2 border-primary"
            )}
          >
            {link.label}
          </Link>
        ))}
      </div>
    </nav>
  );
}
```

### 3. 性能监控实现

#### Step 1: 创建性能监控服务

```typescript
// client/src/services/performance-monitor.ts
interface NavigationMetrics {
  from: string;
  to: string;
  startTime: number;
  endTime?: number;
  duration?: number;
  error?: string;
}

class PerformanceMonitor {
  private currentNavigation: NavigationMetrics | null = null;
  private navigationHistory: NavigationMetrics[] = [];
  private maxHistorySize = 50;
  
  // 开始跟踪导航
  startNavigation(from: string, to: string): void {
    this.currentNavigation = {
      from,
      to,
      startTime: performance.now(),
    };
  }
  
  // 结束跟踪导航
  endNavigation(error?: string): void {
    if (!this.currentNavigation) return;
    
    const endTime = performance.now();
    this.currentNavigation.endTime = endTime;
    this.currentNavigation.duration = endTime - this.currentNavigation.startTime;
    this.currentNavigation.error = error;
    
    // 保存到历史记录
    this.navigationHistory.push(this.currentNavigation);
    if (this.navigationHistory.length > this.maxHistorySize) {
      this.navigationHistory.shift();
    }
    
    // 发送分析数据
    this.reportMetrics(this.currentNavigation);
    
    this.currentNavigation = null;
  }
  
  // 报告性能指标
  private reportMetrics(metrics: NavigationMetrics): void {
    // 发送到分析服务
    if (window.analytics) {
      window.analytics.track('navigation_performance', {
        ...metrics,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        connectionType: (navigator as any).connection?.effectiveType,
      });
    }
    
    // 控制台日志（开发环境）
    if (process.env.NODE_ENV === 'development') {
      console.log(`Navigation: ${metrics.from} → ${metrics.to}`, {
        duration: `${metrics.duration?.toFixed(2)}ms`,
        status: metrics.error ? 'failed' : 'success',
      });
    }
  }
  
  // 获取性能统计
  getStatistics() {
    const successful = this.navigationHistory.filter(n => !n.error);
    const failed = this.navigationHistory.filter(n => n.error);
    
    const avgDuration = successful.length > 0
      ? successful.reduce((sum, n) => sum + (n.duration || 0), 0) / successful.length
      : 0;
    
    const slowest = [...successful].sort((a, b) => (b.duration || 0) - (a.duration || 0))[0];
    const fastest = [...successful].sort((a, b) => (a.duration || 0) - (b.duration || 0))[0];
    
    return {
      total: this.navigationHistory.length,
      successful: successful.length,
      failed: failed.length,
      averageDuration: avgDuration,
      slowestNavigation: slowest,
      fastestNavigation: fastest,
    };
  }
  
  // 收集页面加载性能数据
  collectPageLoadMetrics(): void {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach((entry) => {
          if (entry.entryType === 'navigation') {
            const navEntry = entry as PerformanceNavigationTiming;
            
            window.analytics?.track('page_load_performance', {
              path: window.location.pathname,
              dns: navEntry.domainLookupEnd - navEntry.domainLookupStart,
              tcp: navEntry.connectEnd - navEntry.connectStart,
              request: navEntry.responseStart - navEntry.requestStart,
              response: navEntry.responseEnd - navEntry.responseStart,
              dom: navEntry.domComplete - navEntry.domInteractive,
              load: navEntry.loadEventEnd - navEntry.loadEventStart,
              total: navEntry.loadEventEnd - navEntry.fetchStart,
              timestamp: new Date().toISOString(),
            });
          }
        });
      });
      
      observer.observe({ entryTypes: ['navigation'] });
    }
  }
}

export const performanceMonitor = new PerformanceMonitor();
```

#### Step 2: 创建性能监控Hook

```typescript
// client/src/hooks/use-performance-tracking.ts
import { useEffect } from 'react';
import { useLocation } from 'wouter';
import { performanceMonitor } from '@/services/performance-monitor';

export function usePerformanceTracking() {
  const [location] = useLocation();
  
  useEffect(() => {
    // 初始化页面加载性能收集
    performanceMonitor.collectPageLoadMetrics();
  }, []);
  
  useEffect(() => {
    // 跟踪路由变化
    const previousLocation = sessionStorage.getItem('previous_location') || '/';
    performanceMonitor.startNavigation(previousLocation, location);
    
    // 保存当前位置
    sessionStorage.setItem('previous_location', location);
    
    // 组件加载完成后结束跟踪
    const timer = setTimeout(() => {
      performanceMonitor.endNavigation();
    }, 0);
    
    return () => {
      clearTimeout(timer);
    };
  }, [location]);
  
  return {
    getStatistics: performanceMonitor.getStatistics.bind(performanceMonitor),
  };
}
```

### 4. 实施清单

#### 第一周任务清单

- [ ] 创建权限相关的类型定义文件
- [ ] 实现 usePermissions Hook
- [ ] 创建 RoleRoute 组件
- [ ] 创建 403 错误页面
- [ ] 更新数据库用户表，添加 roles 字段

#### 第二周任务清单

- [ ] 更新所有路由使用新的权限系统
- [ ] 创建路由配置文件
- [ ] 实现预加载管理器
- [ ] 创建预加载 Hook
- [ ] 测试预加载功能

#### 第三周任务清单

- [ ] 更新导航组件支持预加载
- [ ] 实现性能监控服务
- [ ] 集成性能跟踪到应用
- [ ] 创建性能仪表板页面
- [ ] 部署并监控指标

## 测试计划

### 单元测试示例

```typescript
// __tests__/RoleRoute.test.tsx
import { render } from '@testing-library/react';
import { RoleRoute } from '@/components/auth/RoleRoute';

describe('RoleRoute', () => {
  it('should redirect to login when user is not authenticated', () => {
    const { container } = render(
      <RoleRoute 
        path="/admin" 
        component={() => <div>Admin Page</div>}
        roles={['admin']}
      />
    );
    
    expect(mockRedirect).toHaveBeenCalledWith('/platform/auth');
  });
  
  it('should redirect to 403 when user lacks required role', () => {
    mockUseAuth.mockReturnValue({
      user: { id: 1, roles: ['user'] },
      isLoading: false,
    });
    
    render(
      <RoleRoute 
        path="/admin" 
        component={() => <div>Admin Page</div>}
        roles={['admin']}
      />
    );
    
    expect(mockRedirect).toHaveBeenCalledWith('/platform/403');
  });
});
```

### 集成测试示例

```typescript
// __tests__/navigation-preload.test.tsx
import { renderHook } from '@testing-library/react-hooks';
import { useRoutePreload } from '@/hooks/use-route-preload';

describe('Route Preloading', () => {
  it('should preload routes on hover', async () => {
    const { result } = renderHook(() => useRoutePreload());
    
    await result.current.preloadOnHover('/platform/ai-matching');
    
    // 等待防抖
    await new Promise(resolve => setTimeout(resolve, 150));
    
    const status = result.current.getStatus();
    expect(status.loaded).toBeGreaterThan(0);
  });
});
```

## 部署注意事项

1. **环境变量配置**
```bash
# .env.production
VITE_ENABLE_PRELOAD=true
VITE_PERFORMANCE_TRACKING=true
VITE_ANALYTICS_KEY=your-analytics-key
```

2. **Nginx 配置更新**
```nginx
# 支持新的路由结构
location /platform {
    try_files $uri $uri/ /index.html;
}

# 添加缓存头
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
}
```

3. **监控告警配置**
```yaml
# prometheus-alerts.yml
groups:
  - name: navigation
    rules:
      - alert: SlowNavigation
        expr: navigation_duration_seconds > 1
        for: 5m
        annotations:
          summary: "Navigation taking too long"
          
      - alert: HighErrorRate
        expr: rate(navigation_errors_total[5m]) > 0.05
        for: 5m
        annotations:
          summary: "High navigation error rate"
```

---

*指南创建日期: 2024-08-18*
*版本: 1.0.0*